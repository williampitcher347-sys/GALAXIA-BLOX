<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Galaxia 3D Game Creator</title>

  <style>
    body {
      margin: 0;
      background: #000;
      color: #0af;
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex;
      height: 100vh;
    }

    /* LEFT: TOOLS + OBJECTS */
    #sidebar {
      width: 260px;
      background: linear-gradient(180deg, #001, #000);
      border-right: 2px solid #0af;
      padding: 15px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    #sidebar h2 {
      margin: 0;
      color: #0af;
      text-align: center;
      font-size: 20px;
    }

    .tool-btn {
      width: 100%;
      padding: 8px;
      margin-top: 6px;
      background: #0af;
      color: #000;
      border: none;
      cursor: pointer;
      font-weight: bold;
      border-radius: 5px;
      transition: 0.2s;
      font-size: 14px;
    }

    .tool-btn:hover {
      background: #08c;
    }

    .tool-btn.active {
      background: #fff;
      color: #000;
    }

    #objectList {
      flex: 1;
      border: 1px solid #0af;
      padding: 8px;
      overflow-y: auto;
      background: rgba(0, 0, 40, 0.7);
      font-size: 13px;
    }

    .object-item {
      padding: 5px 6px;
      margin-bottom: 4px;
      border-radius: 4px;
      cursor: pointer;
      background: #012;
      border: 1px solid #0af;
    }

    .object-item.selected {
      background: #0af;
      color: #000;
    }

    /* MAIN */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #topbar {
      height: 50px;
      background: #001;
      border-bottom: 2px solid #0af;
      display: flex;
      align-items: center;
      padding: 0 20px;
      font-size: 18px;
      font-weight: bold;
      letter-spacing: 1px;
      justify-content: space-between;
    }

    #topbar span {
      opacity: 0.8;
      font-size: 13px;
    }

    #viewport {
      flex: 1;
      position: relative;
      background: radial-gradient(circle, #001 0%, #000 100%);
    }

    #threeContainer {
      position: absolute;
      inset: 0;
    }

    /* RIGHT: PROPERTIES */
    #properties {
      width: 260px;
      background: #000;
      border-left: 2px solid #0af;
      padding: 15px;
      box-sizing: border-box;
    }

    #properties h2 {
      margin-top: 0;
      text-align: center;
      color: #0af;
      font-size: 20px;
    }

    .prop-label {
      margin-top: 10px;
      font-size: 13px;
    }

    .prop-input {
      width: 100%;
      padding: 6px;
      background: #001;
      border: 1px solid #0af;
      color: #0af;
      margin-top: 4px;
      font-size: 13px;
    }

    #noSelection {
      font-size: 13px;
      opacity: 0.7;
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>

<body>

  <!-- LEFT -->
  <div id="sidebar">
    <div>
      <h2>Tools</h2>
      <button class="tool-btn active" id="toolSelect">Select</button>
      <button class="tool-btn" id="toolAddCube">Add Cube</button>
      <button class="tool-btn" id="toolAddSphere">Add Sphere</button>
      <button class="tool-btn" id="toolDelete">Delete Selected</button>
      <button class="tool-btn" id="toolPlay">Play</button>
      <button class="tool-btn" id="toolStop">Stop</button>
      <button class="tool-btn" id="toolSave">Save</button>
      <button class="tool-btn" id="toolLoad">Load</button>
    </div>

    <div>
      <h2>Objects</h2>
      <div id="objectList"></div>
    </div>
  </div>

  <!-- CENTER -->
  <div id="main">
    <div id="topbar">
      <div>Galaxia 3D Game Creator</div>
      <span>Right-drag: orbit • Wheel: zoom • Select object to edit</span>
    </div>
    <div id="viewport">
      <div id="threeContainer"></div>
    </div>
  </div>

  <!-- RIGHT -->
  <div id="properties">
    <h2>Properties</h2>

    <div id="noSelection">No object selected</div>

    <div id="propPanel" style="display:none;">
      <div class="prop-label">Name</div>
      <input class="prop-input" id="propName" type="text">

      <div class="prop-label">Position X</div>
      <input class="prop-input" id="propPosX" type="number" step="0.1">

      <div class="prop-label">Position Y</div>
      <input class="prop-input" id="propPosY" type="number" step="0.1">

      <div class="prop-label">Position Z</div>
      <input class="prop-input" id="propPosZ" type="number" step="0.1">

      <div class="prop-label">Scale</div>
      <input class="prop-input" id="propScale" type="number" step="0.1">

      <div class="prop-label">Speed</div>
      <input class="prop-input" id="propSpeed" type="number" step="0.1">

      <div class="prop-label">Color</div>
      <input class="prop-input" id="propColor" type="text" placeholder="#00aaff">
    </div>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script src="script.js"></script>
  <script>/*  
   GALAXIA 3D GAME CREATOR – ADVANCED ENGINE  
   Features added:
   - Walls + collision
   - Floors
   - Triggers
   - Event system (onTouch, onClick, onStart)
   - Player controller with collision
   - Object behaviors
*/

//////////////////////////////////////////////////////
// BASIC THREE.JS SETUP
//////////////////////////////////////////////////////

const container = document.getElementById("threeContainer");

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  60,
  container.clientWidth / container.clientHeight,
  0.1,
  2000
);
camera.position.set(8, 6, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);

const dirLight = new THREE.DirectionalLight(0x00aaff, 1.2);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

const grid = new THREE.GridHelper(40, 40, 0x0af, 0x033);
scene.add(grid);

//////////////////////////////////////////////////////
// ENGINE STATE
//////////////////////////////////////////////////////

let objects = []; // {id, name, type, mesh, speed, events: []}
let selectedId = null;
let currentTool = "select";
let playMode = false;
let nextId = 1;

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

//////////////////////////////////////////////////////
// OBJECT CREATION HELPERS
//////////////////////////////////////////////////////

function createMesh(type, color = 0x00aaff) {
  let geom;

  switch (type) {
    case "cube":
      geom = new THREE.BoxGeometry(1, 1, 1);
      break;

    case "sphere":
      geom = new THREE.SphereGeometry(0.5, 24, 24);
      break;

    case "wall":
      geom = new THREE.BoxGeometry(5, 3, 0.5);
      break;

    case "floor":
      geom = new THREE.BoxGeometry(20, 0.5, 20);
      break;

    case "trigger":
      geom = new THREE.BoxGeometry(2, 2, 2);
      break;
  }

  const mat = new THREE.MeshStandardMaterial({
    color,
    metalness: 0.2,
    roughness: 0.6,
    transparent: type === "trigger",
    opacity: type === "trigger" ? 0.25 : 1
  });

  const mesh = new THREE.Mesh(geom, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;

  return mesh;
}

function addObject(type) {
  const mesh = createMesh(type);
  mesh.position.set(0, 0.5, 0);
  scene.add(mesh);

  const obj = {
    id: nextId++,
    name: type.toUpperCase() + " " + nextId,
    type,
    mesh,
    speed: 3,
    events: [] // NEW: event list
  };

  objects.push(obj);
  refreshObjectList();
  selectObject(obj.id);
}

//////////////////////////////////////////////////////
// EVENT SYSTEM
//////////////////////////////////////////////////////

/*
   EVENT FORMAT:
   {
     trigger: "onTouch" | "onClick" | "onStart",
     action: "move" | "rotate" | "teleport" | "delete" | "color",
     params: {...}
   }
*/

function runEvents(triggerType, colliderObj = null) {
  objects.forEach(obj => {
    obj.events.forEach(ev => {
      if (ev.trigger !== triggerType) return;

      // If onTouch, check collision
      if (triggerType === "onTouch" && colliderObj) {
        if (!checkCollision(obj.mesh, colliderObj.mesh)) return;
      }

      runAction(obj, ev);
    });
  });
}

function runAction(obj, ev) {
  switch (ev.action) {
    case "move":
      obj.mesh.position.x += ev.params.x || 0;
      obj.mesh.position.y += ev.params.y || 0;
      obj.mesh.position.z += ev.params.z || 0;
      break;

    case "rotate":
      obj.mesh.rotation.y += ev.params.y || 0;
      break;

    case "teleport":
      obj.mesh.position.set(ev.params.x, ev.params.y, ev.params.z);
      break;

    case "delete":
      scene.remove(obj.mesh);
      objects = objects.filter(o => o.id !== obj.id);
      break;

    case "color":
      obj.mesh.material.color.set(ev.params.color);
      break;
  }
}

//////////////////////////////////////////////////////
// COLLISION SYSTEM
//////////////////////////////////////////////////////

function checkCollision(a, b) {
  a.geometry.computeBoundingBox();
  b.geometry.computeBoundingBox();

  const boxA = a.geometry.boundingBox.clone();
  const boxB = b.geometry.boundingBox.clone();

  boxA.applyMatrix4(a.matrixWorld);
  boxB.applyMatrix4(b.matrixWorld);

  return boxA.intersectsBox(boxB);
}

//////////////////////////////////////////////////////
// PLAYER CONTROLLER (in play mode)
//////////////////////////////////////////////////////

function updatePlayerMovement() {
  const player = objects.find(o => o.type === "cube" && o.id === selectedId);
  if (!player) return;

  const speed = player.speed * 0.1;

  const oldPos = player.mesh.position.clone();

  if (keys["ArrowUp"]) player.mesh.position.z -= speed;
  if (keys["ArrowDown"]) player.mesh.position.z += speed;
  if (keys["ArrowLeft"]) player.mesh.position.x -= speed;
  if (keys["ArrowRight"]) player.mesh.position.x += speed;

  // Collision with walls
  objects.forEach(o => {
    if (o.type === "wall" || o.type === "floor") {
      if (checkCollision(player.mesh, o.mesh)) {
        player.mesh.position.copy(oldPos);
      }
    }
  });

  // Trigger events
  objects.forEach(o => {
    if (o.type === "trigger") {
      if (checkCollision(player.mesh, o.mesh)) {
        runEvents("onTouch", player);
      }
    }
  });
}

//////////////////////////////////////////////////////
// RAYCAST SELECTION
//////////////////////////////////////////////////////

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

renderer.domElement.addEventListener("mousedown", e => {
  if (currentTool !== "select") {
    if (currentTool === "cube") addObject("cube");
    if (currentTool === "sphere") addObject("sphere");
    if (currentTool === "wall") addObject("wall");
    if (currentTool === "floor") addObject("floor");
    if (currentTool === "trigger") addObject("trigger");
    return;
  }

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const meshes = objects.map(o => o.mesh);
  const hits = raycaster.intersectObjects(meshes);

  if (hits.length > 0) {
    const hitMesh = hits[0].object;
    const obj = objects.find(o => o.mesh === hitMesh);
    if (obj) selectObject(obj.id);

    // Click events
    runEvents("onClick");
  } else {
    selectedId = null;
    refreshObjectList();
    updatePropertiesPanel();
  }
});

//////////////////////////////////////////////////////
// UI BINDINGS (same as before)
//////////////////////////////////////////////////////

// (Your existing UI code stays the same — selection, properties, save/load, etc.)

//////////////////////////////////////////////////////
// MAIN LOOP
//////////////////////////////////////////////////////

function update() {
  controls.update();

  if (playMode) {
    updatePlayerMovement();
  }
}

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}

animate();</script>
</body>
</html>
